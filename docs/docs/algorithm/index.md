## 排序算法

| **算法策略**  | **策略思想**                                              | **策略特点**                                                                                   |
|---------------|-----------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 排序          | 通过对数据进行重新排列，将其按照从小到大或从大到小的顺序排序 | 可分为稳定排序和非稳定排序，时间复杂度和空间复杂度因算法不同而异。                             |

| **具体算法**       | **算法思想**                                                                 | **算法特点**                                                                                   |
|--------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 冒泡排序（Bubble Sort）    | 比较相邻元素并交换位置，将较大或较小的值逐步“冒泡”到数组的一端                 | 简单易实现，时间复杂度为 O(n²)，适合小规模数据。                                                |
| 插入排序（Insertion Sort） | 逐步将元素插入到前面的已排序部分，保持局部有序                           | 适合基本有序的数组，时间复杂度为 O(n²)，空间复杂度为 O(1)。                                     |
| 选择排序（Selection Sort） | 在未排序部分中找到最小值，放到已排序部分的末尾                           | 无需额外内存，但效率较低（O(n²)）。                                                            |
| 快速排序（Quick Sort）     | 通过选择基准元素分治递归排序                                           | 平均复杂度为 O(n log n)，但最坏情况下退化为 O(n²)。                                            |
| 归并排序（Merge Sort）     | 利用分治法，将数组分成两部分分别排序后合并                               | 稳定排序，适合大规模数据处理，时间复杂度为 O(n log n)。                                         |

---

## 搜索算法

| **算法策略** | **策略思想**                                 | **策略特点**                                                                                   |
|--------------|----------------------------------------------|-----------------------------------------------------------------------------------------------|
| 搜索         | 在数据或图中定位目标元素或路径               | 有顺序性要求（如二分搜索），适用于图或树的遍历。                                                |

| **具体算法**        | **算法思想**                                                                 | **算法特点**                                                                                   |
|---------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 深度优先搜索（DFS） | 沿路径尽可能深入搜索节点，使用递归或栈实现                                   | 适合解决路径或组合问题，时间复杂度为 O(V+E)。                                                  |
| 广度优先搜索（BFS） | 一层一层地搜索节点，使用队列实现                                             | 适合寻找最短路径或最小步数问题，时间复杂度为 O(V+E)。                                           |
| 二分搜索（Binary Search） | 每次将查找范围缩小一半，快速定位有序数组中的目标元素                      | 需要数据有序，时间复杂度为 O(log n)。                                                         |

---

## 最短路径算法

| **算法策略**      | **策略思想**                                 | **策略特点**                                                                                   |
|-------------------|----------------------------------------------|-----------------------------------------------------------------------------------------------|
| 路径优化          | 动态更新距离信息，找到两点之间或多个点之间的最短路径 | 有单源和多源最短路径之分，时间复杂度和图的稀疏程度相关。                                        |

| **具体算法**             | **算法思想**                                                                 | **算法特点**                                                                                   |
|--------------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| Dijkstra 算法            | 从起点开始动态更新到各节点的最短距离                                         | 适合非负权图，时间复杂度为 O(V²) 或 O(E + V log V)。                                           |
| Floyd 算法               | 利用动态规划求解任意两点间的最短路径                                         | 适合带负权但无负权回路的图，时间复杂度为 O(V³)。                                               |

---

## 动态规划算法

| **算法策略**      | **策略思想**                                              | **策略特点**                                                                                   |
|-------------------|-----------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 递归优化          | 分解问题为子问题，存储中间结果，避免重复计算                 | 适用于具有最优子结构的问题，需要明确状态转移方程。                                              |

| **具体算法**       | **算法思想**                                                                 | **算法特点**                                                                                   |
|--------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 0-1 背包问题        | 每个物品只能选一次，优化背包的总价值                                         | 时间复杂度为 O(n * W)，适用于有限容量的选择问题。                                              |
| 最长公共子序列（LCS） | 记录两个序列的公共子序列长度，逐步构造最长公共子序列                       | 时间复杂度为 O(n * m)，空间复杂度与数组规模相关。                                              |

---

## 字符串算法

| **算法策略**    | **策略思想**                                 | **策略特点**                                                                                   |
|-----------------|----------------------------------------------|-----------------------------------------------------------------------------------------------|
| 匹配与操作      | 模式匹配或哈希计算，处理字符串的匹配和解析问题 | 适用于文本处理、协议解析，时间复杂度与字符串长度相关。                                          |

| **具体算法**      | **算法思想**                                                                 | **算法特点**                                                                                   |
|-------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 暴力匹配算法       | 从主串的每个位置逐字符匹配模式串                                              | 简单易实现，但时间复杂度高，为 O(n * m)。                                                     |
| KMP 算法          | 利用前缀函数优化匹配过程，避免重复比较                                        | 时间复杂度为 O(n + m)，适合长文本的高效匹配。                                                 |
| 字符串哈希         | 将字符串映射为固定长度的哈希值，用于快速比较或判断                           | 时间复杂度为 O(n)，广泛用于字符串相等性判断和索引。                                            |

---

## 贪心算法

| **算法策略**  | **策略思想**                                     | **策略特点**                                                                                   |
|---------------|--------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 局部优化      | 每一步选择局部最优解，期望得到全局最优解           | 适合问题具有贪心选择性质的场景，但无法保证全局最优。                                            |

| **具体算法**          | **算法思想**                                                                 | **算法特点**                                                                                   |
|-----------------------|------------------------------------------------------------------------------|-----------------------------------------------------------------------------------------------|
| 任务调度问题           | 按优先级分配任务，最小化整体完成时间                                         | 时间复杂度通常为 O(n log n)，适合调度问题。                                                    |
| 最小生成树算法（Prim/Kruskal） | 通过选择当前权值最小的边，逐步构造生成树                               | Prim 适合稠密图，Kruskal 适合稀疏图。                                                         |

---