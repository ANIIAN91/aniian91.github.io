import{_ as t,c as d,o as r,R as o}from"./chunks/framework.Cp3V7vRL.js";const y=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"algorithm/index.md","filePath":"algorithm/index.md","lastUpdated":1743044679000}'),h={name:"algorithm/index.md"},a=o('<h2 id="排序算法" tabindex="-1">排序算法 <a class="header-anchor" href="#排序算法" aria-label="Permalink to &quot;排序算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>排序</td><td>通过对数据进行重新排列，将其按照从小到大或从大到小的顺序排序</td><td>可分为稳定排序和非稳定排序，时间复杂度和空间复杂度因算法不同而异。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>冒泡排序（Bubble Sort）</td><td>比较相邻元素并交换位置，将较大或较小的值逐步“冒泡”到数组的一端</td><td>简单易实现，时间复杂度为 O(n²)，适合小规模数据。</td></tr><tr><td>插入排序（Insertion Sort）</td><td>逐步将元素插入到前面的已排序部分，保持局部有序</td><td>适合基本有序的数组，时间复杂度为 O(n²)，空间复杂度为 O(1)。</td></tr><tr><td>选择排序（Selection Sort）</td><td>在未排序部分中找到最小值，放到已排序部分的末尾</td><td>无需额外内存，但效率较低（O(n²)）。</td></tr><tr><td>快速排序（Quick Sort）</td><td>通过选择基准元素分治递归排序</td><td>平均复杂度为 O(n log n)，但最坏情况下退化为 O(n²)。</td></tr><tr><td>归并排序（Merge Sort）</td><td>利用分治法，将数组分成两部分分别排序后合并</td><td>稳定排序，适合大规模数据处理，时间复杂度为 O(n log n)。</td></tr></tbody></table><hr><h2 id="搜索算法" tabindex="-1">搜索算法 <a class="header-anchor" href="#搜索算法" aria-label="Permalink to &quot;搜索算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>搜索</td><td>在数据或图中定位目标元素或路径</td><td>有顺序性要求（如二分搜索），适用于图或树的遍历。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>深度优先搜索（DFS）</td><td>沿路径尽可能深入搜索节点，使用递归或栈实现</td><td>适合解决路径或组合问题，时间复杂度为 O(V+E)。</td></tr><tr><td>广度优先搜索（BFS）</td><td>一层一层地搜索节点，使用队列实现</td><td>适合寻找最短路径或最小步数问题，时间复杂度为 O(V+E)。</td></tr><tr><td>二分搜索（Binary Search）</td><td>每次将查找范围缩小一半，快速定位有序数组中的目标元素</td><td>需要数据有序，时间复杂度为 O(log n)。</td></tr></tbody></table><hr><h2 id="最短路径算法" tabindex="-1">最短路径算法 <a class="header-anchor" href="#最短路径算法" aria-label="Permalink to &quot;最短路径算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>路径优化</td><td>动态更新距离信息，找到两点之间或多个点之间的最短路径</td><td>有单源和多源最短路径之分，时间复杂度和图的稀疏程度相关。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>Dijkstra 算法</td><td>从起点开始动态更新到各节点的最短距离</td><td>适合非负权图，时间复杂度为 O(V²) 或 O(E + V log V)。</td></tr><tr><td>Floyd 算法</td><td>利用动态规划求解任意两点间的最短路径</td><td>适合带负权但无负权回路的图，时间复杂度为 O(V³)。</td></tr></tbody></table><hr><h2 id="动态规划算法" tabindex="-1">动态规划算法 <a class="header-anchor" href="#动态规划算法" aria-label="Permalink to &quot;动态规划算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>递归优化</td><td>分解问题为子问题，存储中间结果，避免重复计算</td><td>适用于具有最优子结构的问题，需要明确状态转移方程。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>0-1 背包问题</td><td>每个物品只能选一次，优化背包的总价值</td><td>时间复杂度为 O(n * W)，适用于有限容量的选择问题。</td></tr><tr><td>最长公共子序列（LCS）</td><td>记录两个序列的公共子序列长度，逐步构造最长公共子序列</td><td>时间复杂度为 O(n * m)，空间复杂度与数组规模相关。</td></tr></tbody></table><hr><h2 id="字符串算法" tabindex="-1">字符串算法 <a class="header-anchor" href="#字符串算法" aria-label="Permalink to &quot;字符串算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>匹配与操作</td><td>模式匹配或哈希计算，处理字符串的匹配和解析问题</td><td>适用于文本处理、协议解析，时间复杂度与字符串长度相关。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>暴力匹配算法</td><td>从主串的每个位置逐字符匹配模式串</td><td>简单易实现，但时间复杂度高，为 O(n * m)。</td></tr><tr><td>KMP 算法</td><td>利用前缀函数优化匹配过程，避免重复比较</td><td>时间复杂度为 O(n + m)，适合长文本的高效匹配。</td></tr><tr><td>字符串哈希</td><td>将字符串映射为固定长度的哈希值，用于快速比较或判断</td><td>时间复杂度为 O(n)，广泛用于字符串相等性判断和索引。</td></tr></tbody></table><hr><h2 id="贪心算法" tabindex="-1">贪心算法 <a class="header-anchor" href="#贪心算法" aria-label="Permalink to &quot;贪心算法&quot;">​</a></h2><table><thead><tr><th><strong>算法策略</strong></th><th><strong>策略思想</strong></th><th><strong>策略特点</strong></th></tr></thead><tbody><tr><td>局部优化</td><td>每一步选择局部最优解，期望得到全局最优解</td><td>适合问题具有贪心选择性质的场景，但无法保证全局最优。</td></tr></tbody></table><table><thead><tr><th><strong>具体算法</strong></th><th><strong>算法思想</strong></th><th><strong>算法特点</strong></th></tr></thead><tbody><tr><td>任务调度问题</td><td>按优先级分配任务，最小化整体完成时间</td><td>时间复杂度通常为 O(n log n)，适合调度问题。</td></tr><tr><td>最小生成树算法（Prim/Kruskal）</td><td>通过选择当前权值最小的边，逐步构造生成树</td><td>Prim 适合稠密图，Kruskal 适合稀疏图。</td></tr></tbody></table><hr>',24),n=[a];function e(s,g,l,b,i,c){return r(),d("div",null,n)}const m=t(h,[["render",e]]);export{y as __pageData,m as default};
